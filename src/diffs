--- integral.c	2022-12-08 11:22:29.000000000 -0700
+++ ../js/integral.js	2022-12-08 11:02:40.000000000 -0700
@@ -1,4 +1,4 @@
-char *integral_tab_exp[] = {
+var integral_tab_exp = [
 
 // x^n exp(a x + b)
 
@@ -237,11 +237,11 @@
 	"x^9 exp(a x^2 + b)",
 	"x^8 exp(a x^2 + b) / (2 a) - 2 x^6 exp(a x^2 + b) / a^2 + 6 x^4 exp(a x^2 + b) / a^3 - 12 x^2 exp(a x^2 + b) / a^4 + 12 exp(a x^2 + b) / a^5",
 	"1",
-};
+];
 
 // log(a x) is transformed to log(a) + log(x)
 
-char *integral_tab_log[] = {
+var integral_tab_log = [
 
 	"log(x)",
 	"x log(x) - x",
@@ -286,9 +286,9 @@
 	"1 / (x (a + log(x)))",
 	"log(a + log(x))",
 	"1",
-};
+];
 
-char *integral_tab_trig[] = {
+var integral_tab_trig = [
 
 	"sin(a x)",
 	"-cos(a x) / a",
@@ -545,9 +545,9 @@
 	"cos(a x)^6 / sin(a x)",
 	"cos(a x)^5 / (5 a) - 2 cos(a x)^3 / (3 a) + 2 cos(a x) / a - cos(a x) sin(a x)^2 / a + log(tan(1/2 a x)) / a",
 	"1",
-};
+];
 
-char *integral_tab_power[] = {
+var integral_tab_power = [
 
 	"a", // for forms c^d where both c and d are constant expressions
 	"a x",
@@ -614,18 +614,18 @@
 	"1",
 // 74
 	"1 / (a x^3 + b)",
-	"-log(a^(2/3) x^2 - a^(1/3) b^(1/3) x + b^(2/3))/(6 a^(1/3) b^(2/3))"
-	" + log(a^(1/3) x + b^(1/3))/(3 a^(1/3) b^(2/3))"
-	" - (i log(1 - (i (1 - (2 a^(1/3) x)/b^(1/3)))/sqrt(3)))/(2 sqrt(3) a^(1/3) b^(2/3))"
+	"-log(a^(2/3) x^2 - a^(1/3) b^(1/3) x + b^(2/3))/(6 a^(1/3) b^(2/3))" +
+	" + log(a^(1/3) x + b^(1/3))/(3 a^(1/3) b^(2/3))" +
+	" - (i log(1 - (i (1 - (2 a^(1/3) x)/b^(1/3)))/sqrt(3)))/(2 sqrt(3) a^(1/3) b^(2/3))" +
 	" + (i log(1 + (i (1 - (2 a^(1/3) x)/b^(1/3)))/sqrt(3)))/(2 sqrt(3) a^(1/3) b^(2/3))", // from Wolfram Alpha
 	"1",
 // 77
 	"1 / (a x^4 + b)",
-	"-log(-sqrt(2) a^(1/4) b^(1/4) x + sqrt(a) x^2 + sqrt(b))/(4 sqrt(2) a^(1/4) b^(3/4))"
-	" + log(sqrt(2) a^(1/4) b^(1/4) x + sqrt(a) x^2 + sqrt(b))/(4 sqrt(2) a^(1/4) b^(3/4))"
-	" - (i log(1 - i (1 - (sqrt(2) a^(1/4) x)/b^(1/4))))/(4 sqrt(2) a^(1/4) b^(3/4))"
-	" + (i log(1 + i (1 - (sqrt(2) a^(1/4) x)/b^(1/4))))/(4 sqrt(2) a^(1/4) b^(3/4))"
-	" + (i log(1 - i ((sqrt(2) a^(1/4) x)/b^(1/4) + 1)))/(4 sqrt(2) a^(1/4) b^(3/4))"
+	"-log(-sqrt(2) a^(1/4) b^(1/4) x + sqrt(a) x^2 + sqrt(b))/(4 sqrt(2) a^(1/4) b^(3/4))" +
+	" + log(sqrt(2) a^(1/4) b^(1/4) x + sqrt(a) x^2 + sqrt(b))/(4 sqrt(2) a^(1/4) b^(3/4))" +
+	" - (i log(1 - i (1 - (sqrt(2) a^(1/4) x)/b^(1/4))))/(4 sqrt(2) a^(1/4) b^(3/4))" +
+	" + (i log(1 + i (1 - (sqrt(2) a^(1/4) x)/b^(1/4))))/(4 sqrt(2) a^(1/4) b^(3/4))" +
+	" + (i log(1 - i ((sqrt(2) a^(1/4) x)/b^(1/4) + 1)))/(4 sqrt(2) a^(1/4) b^(3/4))" +
 	" - (i log(1 + i ((sqrt(2) a^(1/4) x)/b^(1/4) + 1)))/(4 sqrt(2) a^(1/4) b^(3/4))", // from Wolfram Alpha
 	"1",
 // 164
@@ -648,9 +648,9 @@
 	"cosh(x)^2",
 	"sinh(2 x) 1/4 + x 1/2",
 	"1",
-};
+];
 
-char *integral_tab[] = {
+var integral_tab = [
 
 	"a",
 	"a x",
@@ -883,21 +883,20 @@
 	"x^4 (1 - x^2)^(3/2)",
 	"(-x sqrt(1 - x^2) (16 x^6 - 24 x^4 + 2 x^2 + 3) + 3 arcsin(x)) 1/128",
 	"1",
-};
+];
 
-void
-eval_integral(struct atom *p1)
+function
+eval_integral(p1)
 {
-	int flag, i, n;
-	struct atom *X, *Y = NULL; // silence compiler
+	var flag, i, n, X, Y;
 
 	push(cadr(p1));
-	eval();
+	evalf();
 
 	p1 = cddr(p1);
 
 	if (!iscons(p1)) {
-		push_symbol(X_LOWER);
+		push_symbol(SYMBOL_X);
 		integral();
 		return;
 	}
@@ -911,7 +910,7 @@
 			flag = 0;
 		} else {
 			push(car(p1));
-			eval();
+			evalf();
 			X = pop();
 			p1 = cdr(p1);
 		}
@@ -919,7 +918,7 @@
 		if (isnum(X)) {
 			push(X);
 			n = pop_integer();
-			push_symbol(X_LOWER);
+			push_symbol(SYMBOL_X);
 			X = pop();
 			for (i = 0; i < n; i++) {
 				push(X);
@@ -929,12 +928,12 @@
 		}
 
 		if (!isusersymbol(X))
-			stop("integral");
+			stopf("integral");
 
 		if (iscons(p1)) {
 
 			push(car(p1));
-			eval();
+			evalf();
 			Y = pop();
 			p1 = cdr(p1);
 
@@ -956,20 +955,19 @@
 	}
 }
 
-void
-integral(void)
+function
+integral()
 {
-	int h;
-	struct atom *p1, *F, *X;
+	var h, p1, F, X;
 
 	X = pop();
 	F = pop();
 
 	if (!isusersymbol(X))
-		stop("integral: symbol expected");
+		stopf("integral: symbol expected");
 
 	if (car(F) == symbol(ADD)) {
-		h = tos;
+		h = stack.length;
 		p1 = cdr(F);
 		while (iscons(p1)) {
 			push(car(p1));
@@ -977,7 +975,7 @@
 			integral();
 			p1 = cdr(p1);
 		}
-		add_terms(tos - h);
+		add_terms(stack.length - h);
 		return;
 	}
 
@@ -994,10 +992,10 @@
 	integral_nib(F, X);
 }
 
-void
-integral_nib(struct atom *F, struct atom *X)
+function
+integral_nib(F, X)
 {
-	int h;
+	var h;
 
 	save_symbol(symbol(SA));
 	save_symbol(symbol(SB));
@@ -1007,7 +1005,7 @@
 
 	// put constants in F(X) on the stack
 
-	h = tos;
+	h = stack.length;
 
 	push_integer(1); // 1 is a candidate for a or b
 
@@ -1022,37 +1020,37 @@
 	restore_symbol(symbol(SA));
 }
 
-void
-integral_lookup(int h, struct atom *F)
+function
+integral_lookup(h, F)
 {
-	int t;
+	var t;
 
 	t = integral_classify(F);
 
-	if ((t & 1) && integral_search(h, F, integral_tab_exp, sizeof integral_tab_exp / sizeof (char *)))
+	if ((t & 1) && integral_search(h, F, integral_tab_exp, integral_tab_exp.length))
 		return;
 
-	if ((t & 2) && integral_search(h, F, integral_tab_log, sizeof integral_tab_log / sizeof (char *)))
+	if ((t & 2) && integral_search(h, F, integral_tab_log, integral_tab_log.length))
 		return;
 
-	if ((t & 4) && integral_search(h, F, integral_tab_trig, sizeof integral_tab_trig / sizeof (char *)))
+	if ((t & 4) && integral_search(h, F, integral_tab_trig, integral_tab_trig.length))
 		return;
 
 	if (car(F) == symbol(POWER)) {
-		if (integral_search(h, F, integral_tab_power, sizeof integral_tab_power / sizeof (char *)))
+		if (integral_search(h, F, integral_tab_power, integral_tab_power.length))
 			return;
 	} else {
-		if (integral_search(h, F, integral_tab, sizeof integral_tab / sizeof (char *)))
+		if (integral_search(h, F, integral_tab, integral_tab.length))
 			return;
 	}
 
-	stop("integral: no solution found");
+	stopf("integral: no solution found");
 }
 
-int
-integral_classify(struct atom *p)
+function
+integral_classify(p)
 {
-	int t = 0;
+	var t = 0;
 
 	if (iscons(p)) {
 		while (iscons(p)) {
@@ -1074,11 +1072,10 @@
 	return 0;
 }
 
-int
-integral_search(int h, struct atom *F, char **table, int n)
+function
+integral_search(h, F, table, n)
 {
-	int i;
-	struct atom *C, *I;
+	var i, C, I;
 
 	for (i = 0; i < n; i += 3) {
 
@@ -1095,37 +1092,36 @@
 	if (i == n)
 		return 0;
 
-	tos = h; // pop all
+	stack.splice(h); // pop all
 
 	scan1(table[i + 1]); // answer
-	eval();
+	evalf();
 
 	return 1;
 }
 
-int
-integral_search_nib(int h, struct atom *F, struct atom *I, struct atom *C)
+function
+integral_search_nib(h, F, I, C)
 {
-	int i, j;
-	struct atom *p1;
+	var i, j, p1;
 
-	for (i = h; i < tos; i++) {
+	for (i = h; i < stack.length; i++) {
 
 		set_symbol(symbol(SA), stack[i], symbol(NIL));
 
-		for (j = h; j < tos; j++) {
+		for (j = h; j < stack.length; j++) {
 
 			set_symbol(symbol(SB), stack[j], symbol(NIL));
 
 			push(C);			// condition ok?
-			eval();
+			evalf();
 			p1 = pop();
 			if (iszero(p1))
 				continue;		// no, go to next j
 
 			push(F);			// F = I?
 			push(I);
-			eval();
+			evalf();
 			subtract();
 			p1 = pop();
 			if (iszero(p1))
