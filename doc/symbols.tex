\subsection{Symbols}

Symbols are defined using an equals sign.

{\color{blue}
\begin{verbatim}
N = 212^17
\end{verbatim}
}

\noindent
No result is printed when a symbol is defined.
To see the value of a symbol, just evaluate it.

{\color{blue}
\begin{verbatim}
N
\end{verbatim}
}

\noindent
$\displaystyle N=3529471145760275132301897342055866171392$

\bigskip
\noindent
Symbols can have more that one letter.
Everything after the first letter is displayed as a subscript.

{\color{blue}
\begin{verbatim}
NA = 6.02214 10^23
NA
\end{verbatim}
}

\noindent
$\displaystyle N_A=6.02214\times10^{23}$

\bigskip
\noindent
A symbol can be the name of a Greek letter.

{\color{blue}
\begin{verbatim}
xi = 1/2
xi
\end{verbatim}
}

\noindent
$\displaystyle \xi=\tfrac{1}{2}$

\bigskip
\noindent
Greek letters can appear in subscripts.

{\color{blue}
\begin{verbatim}
Amu = 2.0
Amu
\end{verbatim}
}

\noindent
$\displaystyle A_\mu=2.0$

\bigskip
\noindent
The following example shows how a symbol is scanned to find Greek letters.

{\color{blue}
\begin{verbatim}
alphamunu = 1
alphamunu
\end{verbatim}
}

\noindent
$\displaystyle \alpha_{\mu\nu}=1$

\bigskip
\noindent
Symbol definitions are evaluated serially until a terminal symbol is reached.
The following example sets $A=B$ followed by $B=C$.
Then when $A$ is evaluated, the result is $C$.

{\color{blue}
\begin{verbatim}
A = B
B = C
A
\end{verbatim}
}

\noindent
$\displaystyle A=C$

\bigskip
\noindent
Although $A=C$ is printed,
inside the program the binding of $A$ is still $B$, as can be seen with
the \verb$binding$ function.

{\color{blue}
\begin{verbatim}
binding(A)
\end{verbatim}
}

\noindent
$\displaystyle B$

\bigskip
\noindent
The \verb$quote$ function returns its argument unevaluated
and can be used to clear a symbol.
The following example clears $A$ so that its evaluation goes back to
being $A$ instead of $C$.

{\color{blue}
\begin{verbatim}
A = quote(A)
A
\end{verbatim}
}

\noindent
$\displaystyle A$

\subsection{Functions}

\noindent
The syntax for defining functions is {\it function-name} ( {\it arg-list} ) = {\it expr}
where {\it arg-list} is a comma separated list of zero to nine symbols that receive arguments.
Unlike symbol definitions, {\it expr} is not evaluated when {\it function-name} is defined.
Instead, {\it expr} is evaluated when {\it function-name} is used in a subsequent computation.

\bigskip
\noindent
The following example defines a sinc function and evaluates it at $\pi/2$.

{\color{blue}
\begin{verbatim}
f(x) = sin(x)/x
f(pi/2)
\end{verbatim}
}

\noindent
$\displaystyle \frac{2}{\pi}$

\bigskip
\noindent
After a user function is defined, {\it expr} can be recalled using the \verb$binding$ function.

{\color{blue}
\begin{verbatim}
binding(f)
\end{verbatim}
}

\noindent
$\displaystyle \frac{\sin(x)}{x}$

\bigskip
\noindent
If local symbols are needed in a function, they can be appended to {\it arg-list}.
(The caller does not have to supply all the arguments.)
The following example uses Rodrigues's formula to
compute an associated Legendre function of $\cos\theta$.
\begin{equation*}
P_n^m(x)=\frac{1}{2^n\,n!}(1-x^2)^{m/2}\frac{d^{n+m}}{dx^{n+m}}(x^2-1)^n
\end{equation*}

\noindent
Function $P$ below first computes $P_n^m(x)$ for local variable
$x$ and then uses \verb$eval$ to replace $x$ with $f$.
In this case, $f=\cos\theta$.

{\color{blue}
\begin{verbatim}
P(f,n,m,x) = eval(1/(2^n n!) (1 - x^2)^(m/2) d((x^2 - 1)^n,x,n + m),x,f)
P(cos(theta),2,0) -- arguments f, n, m, but not x
\end{verbatim}
}

\noindent
$\displaystyle \tfrac{3}{2} \cos(\theta)^2-\tfrac{1}{2}$

\bigskip
\noindent
The scope of function arguments is the function definition.
